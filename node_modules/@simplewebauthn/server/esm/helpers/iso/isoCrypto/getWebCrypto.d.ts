/// <reference types="node" />
/// <reference types="node" />
/// <reference types="node" />
/// <reference types="node" />
/// <reference types="node/crypto.js" />
/// <reference types="node/crypto.js" />
/// <reference types="node/stream.js" />
/// <reference types="node/stream.js" />
import type { Crypto } from '../../../deps.js';
/**
 * Try to get an instance of the Crypto API from the current runtime. Should support Node,
 * as well as others, like Deno, that implement Web APIs.
 */
export declare function getWebCrypto(): Promise<Crypto>;
export declare class MissingWebCrypto extends Error {
    constructor();
}
export declare const _getWebCryptoInternals: {
    stubThisImportNodeCrypto: () => Promise<{
        default: typeof import("crypto");
        createHash(algorithm: string, options?: import("crypto").HashOptions | undefined): import("crypto").Hash;
        createHash(algorithm: string, options?: import("crypto").HashOptions | undefined): import("crypto").Hash;
        createHmac(algorithm: string, key: import("crypto").KeyObject | import("crypto").BinaryLike, options?: import("stream").TransformOptions | undefined): import("crypto").Hmac;
        createHmac(algorithm: string, key: import("crypto").KeyObject | import("crypto").BinaryLike, options?: import("stream").TransformOptions | undefined): import("crypto").Hmac;
        createCipher(algorithm: import("crypto").CipherCCMTypes, password: import("crypto").BinaryLike, options: import("crypto").CipherCCMOptions): import("crypto").CipherCCM;
        createCipher(algorithm: import("crypto").CipherGCMTypes, password: import("crypto").BinaryLike, options?: import("crypto").CipherGCMOptions | undefined): import("crypto").CipherGCM;
        createCipher(algorithm: string, password: import("crypto").BinaryLike, options?: import("stream").TransformOptions | undefined): import("crypto").Cipher;
        createCipher(algorithm: import("crypto").CipherCCMTypes, password: import("crypto").BinaryLike, options: import("crypto").CipherCCMOptions): import("crypto").CipherCCM;
        createCipher(algorithm: import("crypto").CipherGCMTypes, password: import("crypto").BinaryLike, options?: import("crypto").CipherGCMOptions | undefined): import("crypto").CipherGCM;
        createCipher(algorithm: string, password: import("crypto").BinaryLike, options?: import("stream").TransformOptions | undefined): import("crypto").Cipher;
        createCipheriv(algorithm: import("crypto").CipherCCMTypes, key: import("crypto").CipherKey, iv: import("crypto").BinaryLike, options: import("crypto").CipherCCMOptions): import("crypto").CipherCCM;
        createCipheriv(algorithm: import("crypto").CipherOCBTypes, key: import("crypto").CipherKey, iv: import("crypto").BinaryLike, options: import("crypto").CipherOCBOptions): import("crypto").CipherOCB;
        createCipheriv(algorithm: import("crypto").CipherGCMTypes, key: import("crypto").CipherKey, iv: import("crypto").BinaryLike, options?: import("crypto").CipherGCMOptions | undefined): import("crypto").CipherGCM;
        createCipheriv(algorithm: string, key: import("crypto").CipherKey, iv: import("crypto").BinaryLike | null, options?: import("stream").TransformOptions | undefined): import("crypto").Cipher;
        createCipheriv(algorithm: import("crypto").CipherCCMTypes, key: import("crypto").CipherKey, iv: import("crypto").BinaryLike, options: import("crypto").CipherCCMOptions): import("crypto").CipherCCM;
        createCipheriv(algorithm: import("crypto").CipherOCBTypes, key: import("crypto").CipherKey, iv: import("crypto").BinaryLike, options: import("crypto").CipherOCBOptions): import("crypto").CipherOCB;
        createCipheriv(algorithm: import("crypto").CipherGCMTypes, key: import("crypto").CipherKey, iv: import("crypto").BinaryLike, options?: import("crypto").CipherGCMOptions | undefined): import("crypto").CipherGCM;
        createCipheriv(algorithm: string, key: import("crypto").CipherKey, iv: import("crypto").BinaryLike | null, options?: import("stream").TransformOptions | undefined): import("crypto").Cipher;
        createDecipher(algorithm: import("crypto").CipherCCMTypes, password: import("crypto").BinaryLike, options: import("crypto").CipherCCMOptions): import("crypto").DecipherCCM;
        createDecipher(algorithm: import("crypto").CipherGCMTypes, password: import("crypto").BinaryLike, options?: import("crypto").CipherGCMOptions | undefined): import("crypto").DecipherGCM;
        createDecipher(algorithm: string, password: import("crypto").BinaryLike, options?: import("stream").TransformOptions | undefined): import("crypto").Decipher;
        createDecipher(algorithm: import("crypto").CipherCCMTypes, password: import("crypto").BinaryLike, options: import("crypto").CipherCCMOptions): import("crypto").DecipherCCM;
        createDecipher(algorithm: import("crypto").CipherGCMTypes, password: import("crypto").BinaryLike, options?: import("crypto").CipherGCMOptions | undefined): import("crypto").DecipherGCM;
        createDecipher(algorithm: string, password: import("crypto").BinaryLike, options?: import("stream").TransformOptions | undefined): import("crypto").Decipher;
        createDecipheriv(algorithm: import("crypto").CipherCCMTypes, key: import("crypto").CipherKey, iv: import("crypto").BinaryLike, options: import("crypto").CipherCCMOptions): import("crypto").DecipherCCM;
        createDecipheriv(algorithm: import("crypto").CipherOCBTypes, key: import("crypto").CipherKey, iv: import("crypto").BinaryLike, options: import("crypto").CipherOCBOptions): import("crypto").DecipherOCB;
        createDecipheriv(algorithm: import("crypto").CipherGCMTypes, key: import("crypto").CipherKey, iv: import("crypto").BinaryLike, options?: import("crypto").CipherGCMOptions | undefined): import("crypto").DecipherGCM;
        createDecipheriv(algorithm: string, key: import("crypto").CipherKey, iv: import("crypto").BinaryLike | null, options?: import("stream").TransformOptions | undefined): import("crypto").Decipher;
        createDecipheriv(algorithm: import("crypto").CipherCCMTypes, key: import("crypto").CipherKey, iv: import("crypto").BinaryLike, options: import("crypto").CipherCCMOptions): import("crypto").DecipherCCM;
        createDecipheriv(algorithm: import("crypto").CipherOCBTypes, key: import("crypto").CipherKey, iv: import("crypto").BinaryLike, options: import("crypto").CipherOCBOptions): import("crypto").DecipherOCB;
        createDecipheriv(algorithm: import("crypto").CipherGCMTypes, key: import("crypto").CipherKey, iv: import("crypto").BinaryLike, options?: import("crypto").CipherGCMOptions | undefined): import("crypto").DecipherGCM;
        createDecipheriv(algorithm: string, key: import("crypto").CipherKey, iv: import("crypto").BinaryLike | null, options?: import("stream").TransformOptions | undefined): import("crypto").Decipher;
        generateKey(type: "hmac" | "aes", options: {
            length: number;
        }, callback: (err: Error | null, key: import("crypto").KeyObject) => void): void;
        generateKey(type: "hmac" | "aes", options: {
            length: number;
        }, callback: (err: Error | null, key: import("crypto").KeyObject) => void): void;
        generateKeySync(type: "hmac" | "aes", options: {
            length: number;
        }): import("crypto").KeyObject;
        generateKeySync(type: "hmac" | "aes", options: {
            length: number;
        }): import("crypto").KeyObject;
        createPrivateKey(key: string | import("crypto").PrivateKeyInput | Buffer | import("crypto").JsonWebKeyInput): import("crypto").KeyObject;
        createPrivateKey(key: string | import("crypto").PrivateKeyInput | Buffer | import("crypto").JsonWebKeyInput): import("crypto").KeyObject;
        createPublicKey(key: string | import("crypto").KeyObject | Buffer | import("crypto").JsonWebKeyInput | import("crypto").PublicKeyInput): import("crypto").KeyObject;
        createPublicKey(key: string | import("crypto").KeyObject | Buffer | import("crypto").JsonWebKeyInput | import("crypto").PublicKeyInput): import("crypto").KeyObject;
        createSecretKey(key: NodeJS.ArrayBufferView): import("crypto").KeyObject;
        createSecretKey(key: string, encoding: BufferEncoding): import("crypto").KeyObject;
        createSecretKey(key: NodeJS.ArrayBufferView): import("crypto").KeyObject;
        createSecretKey(key: string, encoding: BufferEncoding): import("crypto").KeyObject;
        createSign(algorithm: string, options?: import("stream").WritableOptions | undefined): import("crypto").Sign;
        createSign(algorithm: string, options?: import("stream").WritableOptions | undefined): import("crypto").Sign;
        createVerify(algorithm: string, options?: import("stream").WritableOptions | undefined): import("crypto").Verify;
        createVerify(algorithm: string, options?: import("stream").WritableOptions | undefined): import("crypto").Verify;
        createDiffieHellman(primeLength: number, generator?: number | undefined): import("crypto").DiffieHellman;
        createDiffieHellman(prime: ArrayBuffer | NodeJS.ArrayBufferView, generator?: number | ArrayBuffer | NodeJS.ArrayBufferView | undefined): import("crypto").DiffieHellman;
        createDiffieHellman(prime: ArrayBuffer | NodeJS.ArrayBufferView, generator: string, generatorEncoding: import("crypto").BinaryToTextEncoding): import("crypto").DiffieHellman;
        createDiffieHellman(prime: string, primeEncoding: import("crypto").BinaryToTextEncoding, generator?: number | ArrayBuffer | NodeJS.ArrayBufferView | undefined): import("crypto").DiffieHellman;
        createDiffieHellman(prime: string, primeEncoding: import("crypto").BinaryToTextEncoding, generator: string, generatorEncoding: import("crypto").BinaryToTextEncoding): import("crypto").DiffieHellman;
        createDiffieHellman(primeLength: number, generator?: number | undefined): import("crypto").DiffieHellman;
        createDiffieHellman(prime: ArrayBuffer | NodeJS.ArrayBufferView, generator?: number | ArrayBuffer | NodeJS.ArrayBufferView | undefined): import("crypto").DiffieHellman;
        createDiffieHellman(prime: ArrayBuffer | NodeJS.ArrayBufferView, generator: string, generatorEncoding: import("crypto").BinaryToTextEncoding): import("crypto").DiffieHellman;
        createDiffieHellman(prime: string, primeEncoding: import("crypto").BinaryToTextEncoding, generator?: number | ArrayBuffer | NodeJS.ArrayBufferView | undefined): import("crypto").DiffieHellman;
        createDiffieHellman(prime: string, primeEncoding: import("crypto").BinaryToTextEncoding, generator: string, generatorEncoding: import("crypto").BinaryToTextEncoding): import("crypto").DiffieHellman;
        getDiffieHellman(groupName: string): import("crypto").DiffieHellmanGroup;
        getDiffieHellman(groupName: string): import("crypto").DiffieHellmanGroup;
        createDiffieHellmanGroup(name: string): import("crypto").DiffieHellmanGroup;
        createDiffieHellmanGroup(name: string): import("crypto").DiffieHellmanGroup;
        pbkdf2(password: import("crypto").BinaryLike, salt: import("crypto").BinaryLike, iterations: number, keylen: number, digest: string, callback: (err: Error | null, derivedKey: Buffer) => void): void;
        pbkdf2(password: import("crypto").BinaryLike, salt: import("crypto").BinaryLike, iterations: number, keylen: number, digest: string, callback: (err: Error | null, derivedKey: Buffer) => void): void;
        pbkdf2Sync(password: import("crypto").BinaryLike, salt: import("crypto").BinaryLike, iterations: number, keylen: number, digest: string): Buffer;
        pbkdf2Sync(password: import("crypto").BinaryLike, salt: import("crypto").BinaryLike, iterations: number, keylen: number, digest: string): Buffer;
        randomBytes(size: number): Buffer;
        randomBytes(size: number, callback: (err: Error | null, buf: Buffer) => void): void;
        randomBytes(size: number): Buffer;
        randomBytes(size: number, callback: (err: Error | null, buf: Buffer) => void): void;
        pseudoRandomBytes(size: number): Buffer;
        pseudoRandomBytes(size: number, callback: (err: Error | null, buf: Buffer) => void): void;
        pseudoRandomBytes(size: number): Buffer;
        pseudoRandomBytes(size: number, callback: (err: Error | null, buf: Buffer) => void): void;
        randomInt(max: number): number;
        randomInt(min: number, max: number): number;
        randomInt(max: number, callback: (err: Error | null, value: number) => void): void;
        randomInt(min: number, max: number, callback: (err: Error | null, value: number) => void): void;
        randomInt(max: number): number;
        randomInt(min: number, max: number): number;
        randomInt(max: number, callback: (err: Error | null, value: number) => void): void;
        randomInt(min: number, max: number, callback: (err: Error | null, value: number) => void): void;
        randomFillSync<T extends NodeJS.ArrayBufferView>(buffer: T, offset?: number | undefined, size?: number | undefined): T;
        randomFillSync<T_1 extends NodeJS.ArrayBufferView>(buffer: T_1, offset?: number | undefined, size?: number | undefined): T_1;
        randomFill<T_2 extends NodeJS.ArrayBufferView>(buffer: T_2, callback: (err: Error | null, buf: T_2) => void): void;
        randomFill<T_3 extends NodeJS.ArrayBufferView>(buffer: T_3, offset: number, callback: (err: Error | null, buf: T_3) => void): void;
        randomFill<T_4 extends NodeJS.ArrayBufferView>(buffer: T_4, offset: number, size: number, callback: (err: Error | null, buf: T_4) => void): void;
        randomFill<T_5 extends NodeJS.ArrayBufferView>(buffer: T_5, callback: (err: Error | null, buf: T_5) => void): void;
        randomFill<T_6 extends NodeJS.ArrayBufferView>(buffer: T_6, offset: number, callback: (err: Error | null, buf: T_6) => void): void;
        randomFill<T_7 extends NodeJS.ArrayBufferView>(buffer: T_7, offset: number, size: number, callback: (err: Error | null, buf: T_7) => void): void;
        scrypt(password: import("crypto").BinaryLike, salt: import("crypto").BinaryLike, keylen: number, callback: (err: Error | null, derivedKey: Buffer) => void): void;
        scrypt(password: import("crypto").BinaryLike, salt: import("crypto").BinaryLike, keylen: number, options: import("crypto").ScryptOptions, callback: (err: Error | null, derivedKey: Buffer) => void): void;
        scrypt(password: import("crypto").BinaryLike, salt: import("crypto").BinaryLike, keylen: number, callback: (err: Error | null, derivedKey: Buffer) => void): void;
        scrypt(password: import("crypto").BinaryLike, salt: import("crypto").BinaryLike, keylen: number, options: import("crypto").ScryptOptions, callback: (err: Error | null, derivedKey: Buffer) => void): void;
        scryptSync(password: import("crypto").BinaryLike, salt: import("crypto").BinaryLike, keylen: number, options?: import("crypto").ScryptOptions | undefined): Buffer;
        scryptSync(password: import("crypto").BinaryLike, salt: import("crypto").BinaryLike, keylen: number, options?: import("crypto").ScryptOptions | undefined): Buffer;
        publicEncrypt(key: import("crypto").RsaPublicKey | import("crypto").RsaPrivateKey | import("crypto").KeyLike, buffer: NodeJS.ArrayBufferView): Buffer;
        publicEncrypt(key: import("crypto").RsaPublicKey | import("crypto").RsaPrivateKey | import("crypto").KeyLike, buffer: NodeJS.ArrayBufferView): Buffer;
        publicDecrypt(key: import("crypto").RsaPublicKey | import("crypto").RsaPrivateKey | import("crypto").KeyLike, buffer: NodeJS.ArrayBufferView): Buffer;
        publicDecrypt(key: import("crypto").RsaPublicKey | import("crypto").RsaPrivateKey | import("crypto").KeyLike, buffer: NodeJS.ArrayBufferView): Buffer;
        privateDecrypt(privateKey: import("crypto").RsaPrivateKey | import("crypto").KeyLike, buffer: NodeJS.ArrayBufferView): Buffer;
        privateDecrypt(privateKey: import("crypto").RsaPrivateKey | import("crypto").KeyLike, buffer: NodeJS.ArrayBufferView): Buffer;
        privateEncrypt(privateKey: import("crypto").RsaPrivateKey | import("crypto").KeyLike, buffer: NodeJS.ArrayBufferView): Buffer;
        privateEncrypt(privateKey: import("crypto").RsaPrivateKey | import("crypto").KeyLike, buffer: NodeJS.ArrayBufferView): Buffer;
        getCiphers(): string[];
        getCiphers(): string[];
        getCurves(): string[];
        getCurves(): string[];
        getFips(): 0 | 1;
        getFips(): 0 | 1;
        setFips(bool: boolean): void;
        setFips(bool: boolean): void;
        getHashes(): string[];
        getHashes(): string[];
        createECDH(curveName: string): import("crypto").ECDH;
        createECDH(curveName: string): import("crypto").ECDH;
        timingSafeEqual(a: NodeJS.ArrayBufferView, b: NodeJS.ArrayBufferView): boolean;
        timingSafeEqual(a: NodeJS.ArrayBufferView, b: NodeJS.ArrayBufferView): boolean;
        generateKeyPairSync(type: "rsa", options: import("crypto").RSAKeyPairOptions<"pem", "pem">): import("crypto").KeyPairSyncResult<string, string>;
        generateKeyPairSync(type: "rsa", options: import("crypto").RSAKeyPairOptions<"pem", "der">): import("crypto").KeyPairSyncResult<string, Buffer>;
        generateKeyPairSync(type: "rsa", options: import("crypto").RSAKeyPairOptions<"der", "pem">): import("crypto").KeyPairSyncResult<Buffer, string>;
        generateKeyPairSync(type: "rsa", options: import("crypto").RSAKeyPairOptions<"der", "der">): import("crypto").KeyPairSyncResult<Buffer, Buffer>;
        generateKeyPairSync(type: "rsa", options: import("crypto").RSAKeyPairKeyObjectOptions): import("crypto").KeyPairKeyObjectResult;
        generateKeyPairSync(type: "rsa-pss", options: import("crypto").RSAPSSKeyPairOptions<"pem", "pem">): import("crypto").KeyPairSyncResult<string, string>;
        generateKeyPairSync(type: "rsa-pss", options: import("crypto").RSAPSSKeyPairOptions<"pem", "der">): import("crypto").KeyPairSyncResult<string, Buffer>;
        generateKeyPairSync(type: "rsa-pss", options: import("crypto").RSAPSSKeyPairOptions<"der", "pem">): import("crypto").KeyPairSyncResult<Buffer, string>;
        generateKeyPairSync(type: "rsa-pss", options: import("crypto").RSAPSSKeyPairOptions<"der", "der">): import("crypto").KeyPairSyncResult<Buffer, Buffer>;
        generateKeyPairSync(type: "rsa-pss", options: import("crypto").RSAPSSKeyPairKeyObjectOptions): import("crypto").KeyPairKeyObjectResult;
        generateKeyPairSync(type: "dsa", options: import("crypto").DSAKeyPairOptions<"pem", "pem">): import("crypto").KeyPairSyncResult<string, string>;
        generateKeyPairSync(type: "dsa", options: import("crypto").DSAKeyPairOptions<"pem", "der">): import("crypto").KeyPairSyncResult<string, Buffer>;
        generateKeyPairSync(type: "dsa", options: import("crypto").DSAKeyPairOptions<"der", "pem">): import("crypto").KeyPairSyncResult<Buffer, string>;
        generateKeyPairSync(type: "dsa", options: import("crypto").DSAKeyPairOptions<"der", "der">): import("crypto").KeyPairSyncResult<Buffer, Buffer>;
        generateKeyPairSync(type: "dsa", options: import("crypto").DSAKeyPairKeyObjectOptions): import("crypto").KeyPairKeyObjectResult;
        generateKeyPairSync(type: "ec", options: import("crypto").ECKeyPairOptions<"pem", "pem">): import("crypto").KeyPairSyncResult<string, string>;
        generateKeyPairSync(type: "ec", options: import("crypto").ECKeyPairOptions<"pem", "der">): import("crypto").KeyPairSyncResult<string, Buffer>;
        generateKeyPairSync(type: "ec", options: import("crypto").ECKeyPairOptions<"der", "pem">): import("crypto").KeyPairSyncResult<Buffer, string>;
        generateKeyPairSync(type: "ec", options: import("crypto").ECKeyPairOptions<"der", "der">): import("crypto").KeyPairSyncResult<Buffer, Buffer>;
        generateKeyPairSync(type: "ec", options: import("crypto").ECKeyPairKeyObjectOptions): import("crypto").KeyPairKeyObjectResult;
        generateKeyPairSync(type: "ed25519", options: import("crypto").ED25519KeyPairOptions<"pem", "pem">): import("crypto").KeyPairSyncResult<string, string>;
        generateKeyPairSync(type: "ed25519", options: import("crypto").ED25519KeyPairOptions<"pem", "der">): import("crypto").KeyPairSyncResult<string, Buffer>;
        generateKeyPairSync(type: "ed25519", options: import("crypto").ED25519KeyPairOptions<"der", "pem">): import("crypto").KeyPairSyncResult<Buffer, string>;
        generateKeyPairSync(type: "ed25519", options: import("crypto").ED25519KeyPairOptions<"der", "der">): import("crypto").KeyPairSyncResult<Buffer, Buffer>;
        generateKeyPairSync(type: "ed25519", options?: import("crypto").ED25519KeyPairKeyObjectOptions | undefined): import("crypto").KeyPairKeyObjectResult;
        generateKeyPairSync(type: "ed448", options: import("crypto").ED448KeyPairOptions<"pem", "pem">): import("crypto").KeyPairSyncResult<string, string>;
        generateKeyPairSync(type: "ed448", options: import("crypto").ED448KeyPairOptions<"pem", "der">): import("crypto").KeyPairSyncResult<string, Buffer>;
        generateKeyPairSync(type: "ed448", options: import("crypto").ED448KeyPairOptions<"der", "pem">): import("crypto").KeyPairSyncResult<Buffer, string>;
        generateKeyPairSync(type: "ed448", options: import("crypto").ED448KeyPairOptions<"der", "der">): import("crypto").KeyPairSyncResult<Buffer, Buffer>;
        generateKeyPairSync(type: "ed448", options?: import("crypto").ED448KeyPairKeyObjectOptions | undefined): import("crypto").KeyPairKeyObjectResult;
        generateKeyPairSync(type: "x25519", options: import("crypto").X25519KeyPairOptions<"pem", "pem">): import("crypto").KeyPairSyncResult<string, string>;
        generateKeyPairSync(type: "x25519", options: import("crypto").X25519KeyPairOptions<"pem", "der">): import("crypto").KeyPairSyncResult<string, Buffer>;
        generateKeyPairSync(type: "x25519", options: import("crypto").X25519KeyPairOptions<"der", "pem">): import("crypto").KeyPairSyncResult<Buffer, string>;
        generateKeyPairSync(type: "x25519", options: import("crypto").X25519KeyPairOptions<"der", "der">): import("crypto").KeyPairSyncResult<Buffer, Buffer>;
        generateKeyPairSync(type: "x25519", options?: import("crypto").X25519KeyPairKeyObjectOptions | undefined): import("crypto").KeyPairKeyObjectResult;
        generateKeyPairSync(type: "x448", options: import("crypto").X448KeyPairOptions<"pem", "pem">): import("crypto").KeyPairSyncResult<string, string>;
        generateKeyPairSync(type: "x448", options: import("crypto").X448KeyPairOptions<"pem", "der">): import("crypto").KeyPairSyncResult<string, Buffer>;
        generateKeyPairSync(type: "x448", options: import("crypto").X448KeyPairOptions<"der", "pem">): import("crypto").KeyPairSyncResult<Buffer, string>;
        generateKeyPairSync(type: "x448", options: import("crypto").X448KeyPairOptions<"der", "der">): import("crypto").KeyPairSyncResult<Buffer, Buffer>;
        generateKeyPairSync(type: "x448", options?: import("crypto").X448KeyPairKeyObjectOptions | undefined): import("crypto").KeyPairKeyObjectResult;
        generateKeyPairSync(type: "rsa", options: import("crypto").RSAKeyPairOptions<"pem", "pem">): import("crypto").KeyPairSyncResult<string, string>;
        generateKeyPairSync(type: "rsa", options: import("crypto").RSAKeyPairOptions<"pem", "der">): import("crypto").KeyPairSyncResult<string, Buffer>;
        generateKeyPairSync(type: "rsa", options: import("crypto").RSAKeyPairOptions<"der", "pem">): import("crypto").KeyPairSyncResult<Buffer, string>;
        generateKeyPairSync(type: "rsa", options: import("crypto").RSAKeyPairOptions<"der", "der">): import("crypto").KeyPairSyncResult<Buffer, Buffer>;
        generateKeyPairSync(type: "rsa", options: import("crypto").RSAKeyPairKeyObjectOptions): import("crypto").KeyPairKeyObjectResult;
        generateKeyPairSync(type: "rsa-pss", options: import("crypto").RSAPSSKeyPairOptions<"pem", "pem">): import("crypto").KeyPairSyncResult<string, string>;
        generateKeyPairSync(type: "rsa-pss", options: import("crypto").RSAPSSKeyPairOptions<"pem", "der">): import("crypto").KeyPairSyncResult<string, Buffer>;
        generateKeyPairSync(type: "rsa-pss", options: import("crypto").RSAPSSKeyPairOptions<"der", "pem">): import("crypto").KeyPairSyncResult<Buffer, string>;
        generateKeyPairSync(type: "rsa-pss", options: import("crypto").RSAPSSKeyPairOptions<"der", "der">): import("crypto").KeyPairSyncResult<Buffer, Buffer>;
        generateKeyPairSync(type: "rsa-pss", options: import("crypto").RSAPSSKeyPairKeyObjectOptions): import("crypto").KeyPairKeyObjectResult;
        generateKeyPairSync(type: "dsa", options: import("crypto").DSAKeyPairOptions<"pem", "pem">): import("crypto").KeyPairSyncResult<string, string>;
        generateKeyPairSync(type: "dsa", options: import("crypto").DSAKeyPairOptions<"pem", "der">): import("crypto").KeyPairSyncResult<string, Buffer>;
        generateKeyPairSync(type: "dsa", options: import("crypto").DSAKeyPairOptions<"der", "pem">): import("crypto").KeyPairSyncResult<Buffer, string>;
        generateKeyPairSync(type: "dsa", options: import("crypto").DSAKeyPairOptions<"der", "der">): import("crypto").KeyPairSyncResult<Buffer, Buffer>;
        generateKeyPairSync(type: "dsa", options: import("crypto").DSAKeyPairKeyObjectOptions): import("crypto").KeyPairKeyObjectResult;
        generateKeyPairSync(type: "ec", options: import("crypto").ECKeyPairOptions<"pem", "pem">): import("crypto").KeyPairSyncResult<string, string>;
        generateKeyPairSync(type: "ec", options: import("crypto").ECKeyPairOptions<"pem", "der">): import("crypto").KeyPairSyncResult<string, Buffer>;
        generateKeyPairSync(type: "ec", options: import("crypto").ECKeyPairOptions<"der", "pem">): import("crypto").KeyPairSyncResult<Buffer, string>;
        generateKeyPairSync(type: "ec", options: import("crypto").ECKeyPairOptions<"der", "der">): import("crypto").KeyPairSyncResult<Buffer, Buffer>;
        generateKeyPairSync(type: "ec", options: import("crypto").ECKeyPairKeyObjectOptions): import("crypto").KeyPairKeyObjectResult;
        generateKeyPairSync(type: "ed25519", options: import("crypto").ED25519KeyPairOptions<"pem", "pem">): import("crypto").KeyPairSyncResult<string, string>;
        generateKeyPairSync(type: "ed25519", options: import("crypto").ED25519KeyPairOptions<"pem", "der">): import("crypto").KeyPairSyncResult<string, Buffer>;
        generateKeyPairSync(type: "ed25519", options: import("crypto").ED25519KeyPairOptions<"der", "pem">): import("crypto").KeyPairSyncResult<Buffer, string>;
        generateKeyPairSync(type: "ed25519", options: import("crypto").ED25519KeyPairOptions<"der", "der">): import("crypto").KeyPairSyncResult<Buffer, Buffer>;
        generateKeyPairSync(type: "ed25519", options?: import("crypto").ED25519KeyPairKeyObjectOptions | undefined): import("crypto").KeyPairKeyObjectResult;
        generateKeyPairSync(type: "ed448", options: import("crypto").ED448KeyPairOptions<"pem", "pem">): import("crypto").KeyPairSyncResult<string, string>;
        generateKeyPairSync(type: "ed448", options: import("crypto").ED448KeyPairOptions<"pem", "der">): import("crypto").KeyPairSyncResult<string, Buffer>;
        generateKeyPairSync(type: "ed448", options: import("crypto").ED448KeyPairOptions<"der", "pem">): import("crypto").KeyPairSyncResult<Buffer, string>;
        generateKeyPairSync(type: "ed448", options: import("crypto").ED448KeyPairOptions<"der", "der">): import("crypto").KeyPairSyncResult<Buffer, Buffer>;
        generateKeyPairSync(type: "ed448", options?: import("crypto").ED448KeyPairKeyObjectOptions | undefined): import("crypto").KeyPairKeyObjectResult;
        generateKeyPairSync(type: "x25519", options: import("crypto").X25519KeyPairOptions<"pem", "pem">): import("crypto").KeyPairSyncResult<string, string>;
        generateKeyPairSync(type: "x25519", options: import("crypto").X25519KeyPairOptions<"pem", "der">): import("crypto").KeyPairSyncResult<string, Buffer>;
        generateKeyPairSync(type: "x25519", options: import("crypto").X25519KeyPairOptions<"der", "pem">): import("crypto").KeyPairSyncResult<Buffer, string>;
        generateKeyPairSync(type: "x25519", options: import("crypto").X25519KeyPairOptions<"der", "der">): import("crypto").KeyPairSyncResult<Buffer, Buffer>;
        generateKeyPairSync(type: "x25519", options?: import("crypto").X25519KeyPairKeyObjectOptions | undefined): import("crypto").KeyPairKeyObjectResult;
        generateKeyPairSync(type: "x448", options: import("crypto").X448KeyPairOptions<"pem", "pem">): import("crypto").KeyPairSyncResult<string, string>;
        generateKeyPairSync(type: "x448", options: import("crypto").X448KeyPairOptions<"pem", "der">): import("crypto").KeyPairSyncResult<string, Buffer>;
        generateKeyPairSync(type: "x448", options: import("crypto").X448KeyPairOptions<"der", "pem">): import("crypto").KeyPairSyncResult<Buffer, string>;
        generateKeyPairSync(type: "x448", options: import("crypto").X448KeyPairOptions<"der", "der">): import("crypto").KeyPairSyncResult<Buffer, Buffer>;
        generateKeyPairSync(type: "x448", options?: import("crypto").X448KeyPairKeyObjectOptions | undefined): import("crypto").KeyPairKeyObjectResult;
        generateKeyPair: typeof import("crypto").generateKeyPair;
        sign(algorithm: string | null | undefined, data: NodeJS.ArrayBufferView, key: import("crypto").KeyLike | import("crypto").SignKeyObjectInput | import("crypto").SignPrivateKeyInput): Buffer;
        sign(algorithm: string | null | undefined, data: NodeJS.ArrayBufferView, key: import("crypto").KeyLike | import("crypto").SignKeyObjectInput | import("crypto").SignPrivateKeyInput, callback: (error: Error | null, data: Buffer) => void): void;
        sign(algorithm: string | null | undefined, data: NodeJS.ArrayBufferView, key: import("crypto").KeyLike | import("crypto").SignKeyObjectInput | import("crypto").SignPrivateKeyInput): Buffer;
        sign(algorithm: string | null | undefined, data: NodeJS.ArrayBufferView, key: import("crypto").KeyLike | import("crypto").SignKeyObjectInput | import("crypto").SignPrivateKeyInput, callback: (error: Error | null, data: Buffer) => void): void;
        verify(algorithm: string | null | undefined, data: NodeJS.ArrayBufferView, key: import("crypto").KeyLike | import("crypto").VerifyKeyObjectInput | import("crypto").VerifyPublicKeyInput | import("crypto").VerifyJsonWebKeyInput, signature: NodeJS.ArrayBufferView): boolean;
        verify(algorithm: string | null | undefined, data: NodeJS.ArrayBufferView, key: import("crypto").KeyLike | import("crypto").VerifyKeyObjectInput | import("crypto").VerifyPublicKeyInput | import("crypto").VerifyJsonWebKeyInput, signature: NodeJS.ArrayBufferView, callback: (error: Error | null, result: boolean) => void): void;
        verify(algorithm: string | null | undefined, data: NodeJS.ArrayBufferView, key: import("crypto").KeyLike | import("crypto").VerifyKeyObjectInput | import("crypto").VerifyPublicKeyInput | import("crypto").VerifyJsonWebKeyInput, signature: NodeJS.ArrayBufferView): boolean;
        verify(algorithm: string | null | undefined, data: NodeJS.ArrayBufferView, key: import("crypto").KeyLike | import("crypto").VerifyKeyObjectInput | import("crypto").VerifyPublicKeyInput | import("crypto").VerifyJsonWebKeyInput, signature: NodeJS.ArrayBufferView, callback: (error: Error | null, result: boolean) => void): void;
        diffieHellman(options: {
            privateKey: import("crypto").KeyObject;
            publicKey: import("crypto").KeyObject;
        }): Buffer;
        diffieHellman(options: {
            privateKey: import("crypto").KeyObject;
            publicKey: import("crypto").KeyObject;
        }): Buffer;
        getCipherInfo(nameOrNid: string | number, options?: import("crypto").CipherInfoOptions | undefined): import("crypto").CipherInfo | undefined;
        getCipherInfo(nameOrNid: string | number, options?: import("crypto").CipherInfoOptions | undefined): import("crypto").CipherInfo | undefined;
        hkdf(digest: string, irm: import("crypto").KeyObject | import("crypto").BinaryLike, salt: import("crypto").BinaryLike, info: import("crypto").BinaryLike, keylen: number, callback: (err: Error | null, derivedKey: ArrayBuffer) => void): void;
        hkdf(digest: string, irm: import("crypto").KeyObject | import("crypto").BinaryLike, salt: import("crypto").BinaryLike, info: import("crypto").BinaryLike, keylen: number, callback: (err: Error | null, derivedKey: ArrayBuffer) => void): void;
        hkdfSync(digest: string, ikm: import("crypto").KeyObject | import("crypto").BinaryLike, salt: import("crypto").BinaryLike, info: import("crypto").BinaryLike, keylen: number): ArrayBuffer;
        hkdfSync(digest: string, ikm: import("crypto").KeyObject | import("crypto").BinaryLike, salt: import("crypto").BinaryLike, info: import("crypto").BinaryLike, keylen: number): ArrayBuffer;
        secureHeapUsed(): import("crypto").SecureHeapUsage;
        secureHeapUsed(): import("crypto").SecureHeapUsage;
        randomUUID(options?: import("crypto").RandomUUIDOptions | undefined): `${string}-${string}-${string}-${string}-${string}`;
        randomUUID(options?: import("crypto").RandomUUIDOptions | undefined): `${string}-${string}-${string}-${string}-${string}`;
        generatePrime(size: number, callback: (err: Error | null, prime: ArrayBuffer) => void): void;
        generatePrime(size: number, options: import("crypto").GeneratePrimeOptionsBigInt, callback: (err: Error | null, prime: bigint) => void): void;
        generatePrime(size: number, options: import("crypto").GeneratePrimeOptionsArrayBuffer, callback: (err: Error | null, prime: ArrayBuffer) => void): void;
        generatePrime(size: number, options: import("crypto").GeneratePrimeOptions, callback: (err: Error | null, prime: bigint | ArrayBuffer) => void): void;
        generatePrime(size: number, callback: (err: Error | null, prime: ArrayBuffer) => void): void;
        generatePrime(size: number, options: import("crypto").GeneratePrimeOptionsBigInt, callback: (err: Error | null, prime: bigint) => void): void;
        generatePrime(size: number, options: import("crypto").GeneratePrimeOptionsArrayBuffer, callback: (err: Error | null, prime: ArrayBuffer) => void): void;
        generatePrime(size: number, options: import("crypto").GeneratePrimeOptions, callback: (err: Error | null, prime: bigint | ArrayBuffer) => void): void;
        generatePrimeSync(size: number): ArrayBuffer;
        generatePrimeSync(size: number, options: import("crypto").GeneratePrimeOptionsBigInt): bigint;
        generatePrimeSync(size: number, options: import("crypto").GeneratePrimeOptionsArrayBuffer): ArrayBuffer;
        generatePrimeSync(size: number, options: import("crypto").GeneratePrimeOptions): bigint | ArrayBuffer;
        generatePrimeSync(size: number): ArrayBuffer;
        generatePrimeSync(size: number, options: import("crypto").GeneratePrimeOptionsBigInt): bigint;
        generatePrimeSync(size: number, options: import("crypto").GeneratePrimeOptionsArrayBuffer): ArrayBuffer;
        generatePrimeSync(size: number, options: import("crypto").GeneratePrimeOptions): bigint | ArrayBuffer;
        checkPrime(value: import("crypto").LargeNumberLike, callback: (err: Error | null, result: boolean) => void): void;
        checkPrime(value: import("crypto").LargeNumberLike, options: import("crypto").CheckPrimeOptions, callback: (err: Error | null, result: boolean) => void): void;
        checkPrime(value: import("crypto").LargeNumberLike, callback: (err: Error | null, result: boolean) => void): void;
        checkPrime(value: import("crypto").LargeNumberLike, options: import("crypto").CheckPrimeOptions, callback: (err: Error | null, result: boolean) => void): void;
        checkPrimeSync(candidate: import("crypto").LargeNumberLike, options?: import("crypto").CheckPrimeOptions | undefined): boolean;
        checkPrimeSync(candidate: import("crypto").LargeNumberLike, options?: import("crypto").CheckPrimeOptions | undefined): boolean;
        setEngine(engine: string, flags?: number | undefined): void;
        setEngine(engine: string, flags?: number | undefined): void;
        getRandomValues<T_8 extends import("crypto").webcrypto.BufferSource>(typedArray: T_8): T_8;
        getRandomValues<T_9 extends import("crypto").webcrypto.BufferSource>(typedArray: T_9): T_9;
        Certificate: typeof import("crypto").Certificate;
        constants: typeof import("crypto").constants;
        fips: boolean;
        Hash: typeof import("crypto").Hash;
        Hmac: typeof import("crypto").Hmac;
        KeyObject: typeof import("crypto").KeyObject;
        Cipher: typeof import("crypto").Cipher;
        Decipher: typeof import("crypto").Decipher;
        Sign: typeof import("crypto").Sign;
        Verify: typeof import("crypto").Verify;
        DiffieHellman: typeof import("crypto").DiffieHellman;
        DiffieHellmanGroup: import("crypto").DiffieHellmanGroupConstructor;
        ECDH: typeof import("crypto").ECDH;
        DEFAULT_ENCODING: BufferEncoding;
        X509Certificate: typeof import("crypto").X509Certificate;
        subtle: import("crypto").webcrypto.SubtleCrypto;
        webcrypto: import("crypto").webcrypto.Crypto;
    } | {
        webcrypto: undefined;
    }>;
    stubThisGlobalThisCrypto: () => globalThis.Crypto;
    setCachedCrypto: (newCrypto: Crypto | undefined) => void;
};
